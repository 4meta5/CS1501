# Rust and WASM

Notes from [Rust and WebAssembly](https://rustwasm.github.io/book/#how-to-read-this-book). May also add notes from [The Rusty Web](https://davidmcneil.github.io/the-rusty-web/). 

* [Review](#review)

## Reviewing JavaScript, HTML, CSS <a name="review"></a>

> [Mozilla Docs](https://developer.mozilla.org/en-US/docs/Learn)

## Rusty WASM Book

> [Setup](https://rustwasm.github.io/book/game-of-life/setup.html)

We use ```wasm-pack``` to orchestrate the following:
* Ensure that we have Rust 1.30 (or newer) and the ```wasm32-unknown-unknown``` target installed via ```rustup```
* Compile Rust sources into a WebAssembly ```.wasm``` binary via ```cargo```
* Use ```wasm-bindgen``` to generate the JavaScript API for using Rust-generated WebAssembly

To do this, we can execute the following command in our project directory (note that there are specific dependencies in the initial Rust cargo project):
```
wasm-pack build
```
This puts the artifacts in the ```pkg``` directory with the following contents:
```
pkg/
├── package.json
├── README.md
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.d.ts
└── wasm_game_of_life.js
```
The ```.wasm``` file is the WebAssembly binary that is generated by the Rust compiler from our Rust sources. 

The ```.js``` file is generated by ```wasm-bindgen``` and contains JavaScript glue for importing DOM and JavaScript functions into Rust. It exposes a nice API to the WebAssembly functions to JavaScript. 

The ```.d.ts``` file contains TypeScript type declarations for the JavaScript glue. If we don't use TypeScript, we can ignore this file.

The ```package.json``` file contains metadata about the generated JavaScript and WebAssembly package. This is used by npm and JavaScript bundlers to determine dependencies across packages, package names, versions, and a bunch of other stuff. It helps us integrate with JavaScript tooling and allows us to publish our package to npm.

In order to take our package and use it in a web page, we can use the ```create-wasm-app``` JavaScript package template. In our main directory, we can run the command:
```
npm init wasm-app www
```
This creates a new subdirectory with the following content:

```
wasm-game-of-life/www/
├── bootstrap.js
├── index.html
├── index.js
├── LICENSE-APACHE
├── LICENSE-MIT
├── package.json
├── README.md
└── webpack.config.js
```
In this subdirectory, the ```package.json``` comes pre-configured with ```webpack``` and ```webpack-dev-server``` dependencies.

The ```index.js``` file is the main entry point for our Web page's JavaScript. 

The next step is to ensure the local development server and its dependencies are installed by running ```npm install``` in the ```www/``` subdirectory.

Next, we want to run ```npm link``` inside the ```pkg/``` subdirectory so that the local package can be depended upon by other local packages without publishing them to npm.

Next, we use the ```npm link```ed version from ```www``` package by running the following command in the ```www/``` subdirectory:
```
npm link wasm-game-of-life
```


Within ```www/```, we run ```npm run start``` in another terminal and the site will be served at ```htttp://localhost:8080/```.

### Interfacing Rust and JavaScript
JavaScript's garbage-collected heap is distinct from WebAssembly's linear memory space (which is where the Rust values live). Although WebAssembly currently has no direct access to the garbage-collected heap, JavaScript can read and write to the WebAssembly linear memory space (but only as an ```ArrayBuffer```); likewise, WebAssembly functions also take and return scalar values. 